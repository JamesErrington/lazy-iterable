import { LazyIterable } from "./lazyIterable";
import { AsyncLazyIterable } from "./asyncLazyIterable";
/**
 * Returns a [[LazyIterable]] that yields the elements of the given iterable alongside the index as an array pair.
 *
 * This method is lazy, as opposed to the built in `Array.forEach()` method. This means it can be chained with other methods without building intermediate arrays,
 * or as a more powerful version of a `for..of` loop.
 *
 * @example Enumerate an iterable
 * ```typescript
 * for (const [index, value] of enumerate(["A", "B", "C"])) {
 *   console.log(`${index}: ${value}`)
 * }
 * ```
 *
 * @see [[enumerateAsync]] for the async version
 * @param iterable The iterable to enumerate
 * @returns
 */
export function enumerate<T>(iterable: Iterable<T>): LazyIterable<[number, T]> {
  return new LazyIterable(
    (function* () {
      let i = 0;
      for (const value of iterable) {
        yield [i, value] as [number, T];
        i++;
      }
    })(),
  );
}
/**
 * Async version of [[enumerate]].
 *
 * @example Enumerate an [[AsyncLazyIterable]]
 * ```typescript
 * async function* generator() { yield* ["A", "B", "C", "D"] }
 * const result = await enumerateAsync(new AsyncLazyIterable(generator())).toArray() // Returns [[0, "A"], [1, "B"], [2, "C"], [3, "D"]]
 * ```
 *
 * @see [[enumerate]] for the synchronous version
 * @param iterable The async iterable to enumerate
 * @returns
 */
export function enumerateAsync<T>(iterable: AsyncIterable<T>): AsyncLazyIterable<[number, T]> {
  return new AsyncLazyIterable(
    (async function* () {
      let i = 0;
      for await (const value of iterable) {
        yield [i, value] as [number, T];
        i++;
      }
    })(),
  );
}
/**
 * Returns a [[LazyIterable]] that yields values between `start` (inclusive) and `stop` (exclusive), in steps of size `step` (default 1).
 * `Start` can be greater than `stop`, in which case the [[LazyIterable]] will yield decreasing values - `step` should still be positive in this case.
 *
 * @example Generate ranges of numbers
 * ```typescript
 * range(0, 5).toArray() // Returns [0, 1, 2, 3, 4]
 * range(0, 10, 2).toArray() // Returns [0, 2, 4, 6, 8]
 * range(20, 0, 5).toArray() // Returns [20, 15, 10, 5]
 * ```
 *
 * @param start The first value to be yielded from the [[LazyIterable]]
 * @param stop The bound on the last value to be yielded
 * @param step The difference between successive yielded values
 * @returns
 */
export function range(start: number, stop: number, step: number = 1): LazyIterable<number> {
  if (step === 0) {
    console.warn("[LazyIterable] Constant range iterable detected - prefer to use 'repeat(item)'");
  }

  if (start < stop) {
    if (step < 0) {
      console.warn("[LazyIterable] Infinite range iterable detected - prefer to use 'infinite(start, step)'");
    }

    return new LazyIterable(
      (function* () {
        for (let i = start; i < stop; i += step) {
          yield i;
        }
      })(),
    );
  }

  if (step < 0) {
    console.warn("[LazyIterable] Infinite range iterable detected - prefer to use 'infinite(start, step)'");
  }

  return new LazyIterable(
    (function* () {
      for (let i = start; i > stop; i -= step) {
        yield i;
      }
    })(),
  );
}
/**
 * Returns a [[LazyIterable]] that yields the given value infinitely.
 *
 * @example Generate an infinite stream of the value 1
 * ```
 * repeat(1).take(5).toArray() // Returns [1, 1, 1, 1, 1]
 * ```
 *
 * @param value
 * @returns
 */
export function repeat<T>(value: T): LazyIterable<T> {
  return new LazyIterable(
    (function* () {
      while (true) {
        yield value;
      }
    })(),
  );
}
/**
 * Returns a [[LazyIterable]] that yields an unending steam of numbers, starting at `start` and separated by `step`.
 * Both `start` and `step` default to 1.
 *
 * @example Generate an infinite increasing list
 * ```
 * infinite(0, 1).take(5).toArray() // Returns [0, 1, 2, 3, 4]
 * ```
 *
 * @param start The first number yielded from the [[LazyIterable]]
 * @param step The gap between sucessive yielded values
 * @returns
 */
export function infinite(start: number = 1, step: number = 1): LazyIterable<number> {
  if (step === 0) {
    console.warn("[LazyIterable] Repeat iterable detected - prefer to use 'repeat(value)'");
  }

  return new LazyIterable(
    (function* () {
      let i = start;
      while (true) {
        yield i;
        i += step;
      }
    })(),
  );
}
/**
 * Returns a [[LazyIterable]] that yields pairs of values as an array, generated by iterating both provided iterables. The number of elements
 * yielded by the resulting [[LazyIterable]] is the length of the shorter of the two iterables.
 *
 * @example Zip two arrays together
 * ```typescript
 * zip(["A", "B", "C"], [1, 2, 3]).toArray() // Returns [["A", 1], ["B", 2], ["C", 3]]
 * ```
 *
 * @see [[zipWith]] for a combination of [[zip]] and [[map]].
 * @param iterableA
 * @param iterableB
 * @returns
 */
export function zip<A, B>(iterableA: Iterable<A>, iterableB: Iterable<B>): LazyIterable<[A, B]> {
  const iterators = [iterableA, iterableB].map((iterable: Iterable<A | B>) => LazyIterable.fromIterable(iterable));
  return new LazyIterable(
    (function* () {
      while (true) {
        const results = iterators.map(iterator => iterator.next());

        if (results.some(result => result.done)) {
          return;
        }
        yield results.map(result => result.value) as [A, B];
      }
    })(),
  );
}
/**
 * Returns a [[LazyIterable]] that yields values generated by zipping the two given iterables and passing the results through the provided callback;
 * effectively, a combination of [[zip]] and [[map]].
 *
 * @example Combine two iterables together with a callback
 * ```
 * zipWith((a, b) => `${a} => ${b}`, ["A", "B", "C"], [1, 2, 3]).toArray() // Returns ["A => 1", "B => 2", "C => 3"]
 * ```
 *
 * @see [[zip]] for the basic method.
 * @param callback
 * @param iterableA
 * @param iterableB
 * @returns
 */
export function zipWith<A, B, C>(
  callback: (a: A, b: B, index: number) => C,
  iterableA: Iterable<A>,
  iterableB: Iterable<B>,
): LazyIterable<C> {
  return new LazyIterable(
    (function* () {
      for (const [i, [valueA, valueB]] of enumerate(zip(iterableA, iterableB))) {
        yield callback(valueA, valueB, i);
      }
    })(),
  );
}
