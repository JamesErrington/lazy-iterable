import { LazyIterable } from "./lazyIterable";
import { enumerateAsync } from "./functions";
/**
 * @author James Errington <james.errington@protonmail.com>
 * @since 1.0.0
 *
 * A wrapper class that encapsulates a lazyily-evaluated iterable, where each value can be generated by some async action.
 * Note that while the actions individually can be async i.e. not guaranteed to return immediately, they are generated in serial;
 * when iterating a [[AsyncLazyIterable]], the first element must be generated before the second can start. This is not always the preferred
 * behaviour, and it may be the case that methods such as `Promise.all` are more suited in some use cases, when async actions can be run in parallel.
 *
 * @typeParam T - The type yielded from the [[AsyncLazyIterable]]
 */
export class AsyncLazyIterable<T> {
  /**
   * @hidden
   */
  private readonly generator: AsyncGenerator<T>;
  /**
   * @example
   * Create a new [[AsyncLazyIterable]] from an async generator function:
   * ```typescript
   * async function* generator() {
   *   for (let i = 0; i < 10; i++) {
   *     yield i
   *   }
   * }
   *
   * const iterable = new AsyncLazyIterable(generator())
   * ```
   *
   * @param generator The generator to be wrapped in the [[AsyncLazyIterable]]
   *
   * @since 1.0.0
   */
  public constructor(generator: AsyncGenerator<T>) {
    this.generator = generator;
  }
  /**
   * @hidden
   */
  [Symbol.asyncIterator](): AsyncGenerator<T> {
    return this.generator;
  }
  /**
   * Returns a `Promise` to an object with two properties: `value`, and `done`. `value` holds the next value of the iteration sequence,
   * based on the current state of the internal generator. `done` is `true` if the last value of the generator has already been consumed,
   * otherwise `false`.
   *
   * @example Using the `next` method to manually iterate a [[AsyncLazyIterable]]
   * ```typescript
   * async function* asyncGenerator() { yield* [1, 2, 3] }
   *
   * const iterable = new AsyncLazyIterable(asyncGenerator())
   * await iterable.next() // Returns { value: 1, done: false }
   * await iterable.next() // Returns { value: 2, done: false }
   * await iterable.next() // Returns { value: 3, done: false }
   * await iterable.next() // Returns { value: undefined, done: true }
   * // All subsequent calls to next() return { value: undefined, done: true }
   * ```
   *
   * @returns The result from one iteration of the generator
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators|MDN - Iterators and generators} for more detail
   * @since 1.0.0
   * @category Eager
   */
  public async next(): Promise<IteratorResult<T>> {
    return this.generator.next();
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that yields the first `items` number of values from the base generator.
   *
   * @param items The number of values to take from the generator
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.take]] for more information
   * @see {@link https://www.learnrxjs.io/learn-rxjs/operators/filtering/take|LearnRxJS - take} for the RxJS version
   * @since 1.0.0
   * @category Lazy
   */
  public take(items: number): AsyncLazyIterable<T> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        for await (const [i, value] of enumerateAsync(self)) {
          if (i >= items) {
            return;
          }
          yield value;
        }
      })(),
    );
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that yields values from the base generator until the provided `predicate` is `false`.
   * This is different to [[filter]] in that no values after the first `false` response are yielded.
   *
   * @param predicate
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.takeWhile]] for more information
   * @see {@link https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile|LearnRxJS - takeWhile} for the RxJS version
   * @since 1.0.0
   * @category Lazy
   */
  public takeWhile(predicate: (value: T, index: number) => boolean): AsyncLazyIterable<T> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        for await (const [i, value] of enumerateAsync(self)) {
          if (predicate(value, i)) {
            yield value;
          } else {
            return;
          }
        }
      })(),
    );
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that ignores the first `items` values from the base generator before yielding.
   *
   * @param items The number of values to ignore from the generator
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.drop]] for more information
   * @see {@link https://www.learnrxjs.io/learn-rxjs/operators/filtering/skip|LearnRxJS - skip} for the RxJS version
   * @since 1.0.0
   * @category Lazy
   */
  public drop(items: number): AsyncLazyIterable<T> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        for await (const [i, value] of enumerateAsync(self)) {
          if (i >= items) {
            yield value;
          }
        }
      })(),
    );
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that ignores values from the base generator until the provided `predicate` is false.
   *
   * @param predicate
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.dropWhile]] for more information
   * @see {@link https://www.learnrxjs.io/learn-rxjs/operators/filtering/skipwhile|LearnRxJS - skipWhile} for the RxJS version
   * @since 1.0.0
   * @category Lazy
   */
  public dropWhile(predicate: (value: T, index: number) => boolean): AsyncLazyIterable<T> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        let dropping = true;
        for await (const [i, value] of enumerateAsync(self)) {
          if (dropping && predicate(value, i) === false) {
            dropping = false;
          }

          if (dropping === false) {
            yield value;
          }
        }
      })(),
    );
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that yields the result of applying the provided `callback` to values from the base generator.
   *
   * @typeParam S - The type returned by the callback
   * @param callback
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.map]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|MDN - Array.prototype.map()} for the standard `Array` method.
   * @since 1.0.0
   * @category Lazy
   */
  public map<S>(callback: (value: T, index: number) => S): AsyncLazyIterable<S> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        for await (const [i, value] of enumerateAsync(self)) {
          yield callback(value, i);
        }
      })(),
    );
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that yields only those values from the base generator for which the provided `predicate` is `true`.
   *
   * @param predicate
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.filter]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter|MDN - Array.prototype.filter()} for the standard `Array` method.
   * @since 1.0.0
   * @category Lazy
   */
  public filter(predicate: (value: T, index: number) => boolean): AsyncLazyIterable<T> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        for await (const [i, value] of enumerateAsync(self)) {
          if (predicate(value, i)) {
            yield value;
          }
        }
      })(),
    );
  }
  /**
   * Performs an effectful callback `effect` for each value yielded from the base generator,
   * and returns a new [[AsyncLazyIterable]] that just passes the values on. Can be considered a helper function
   * for an effectful [[map]] on the identity function, or a lazy version of [[forEach]].
   *
   * @param effect
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.runEffect]] for more information
   * @since 1.0.0
   * @category Lazy
   */
  public runEffect(effect: (value: T, index: number) => unknown): AsyncLazyIterable<T> {
    const self = this;
    return new AsyncLazyIterable(
      (async function* () {
        for await (const [i, value] of enumerateAsync(self)) {
          effect(value, i);
          yield value;
        }
      })(),
    );
  }
  /**
   * Returns a new [[AsyncLazyIterable]] that yields the values returned from calling the provided `generator` with values from the base generator.
   * Can be considered a generalisation of the other lazy processing methods, and is useful when more complex processing is required;
   * for example, when stateful knowledge of past values is needed.
   *
   * @param generatorFunc
   * @returns A new [[AsyncLazyIterable]], for chaining
   *
   * @see [[LazyIterable.feedTo]] for more information
   * @since 1.0.0
   * @category Lazy
   */
  public feedTo<S>(generatorFunc: (seed: AsyncIterable<T>) => AsyncGenerator<S>): AsyncLazyIterable<S> {
    return new AsyncLazyIterable(generatorFunc(this));
  }
  /**
   * Similar to [[runEffect]], calls the given `callback` for each value yielded from the [[AsyncLazyIterable]], but does not return a new iterable.
   * As an eager method, calling `forEach` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @param callback
   *
   * @see [[LazyIterable.forEach]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|MDN - Array.prototype.forEach()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async forEach(callback: (value: T, index: number) => void): Promise<void> {
    for await (const [i, value] of enumerateAsync(this)) {
      callback(value, i);
    }
  }
  /**
   * Applies the given `reducer` function for each value yielded from the [[AsyncLazyIterable]], returning a single output value.
   * As an eager method, calling `reduce` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @typeParam S - The type of the accumulated value
   * @param reducer The function to apply for each value yielded
   * @param initial The initial value for the accumulator
   * @returns A `Promise` that resolves to the final result of the reduction
   *
   * @see [[LazyIterable.reduce]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce|MDN - Array.prototype.reduce()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async reduce<S>(reducer: (accumulator: S, value: T, index: number) => S, initial: S): Promise<S> {
    let accumulator = initial;
    for await (const [i, value] of enumerateAsync(this)) {
      accumulator = reducer(accumulator, value, i);
    }
    return accumulator;
  }
  /**
   * Tests values yielded from the [[AsyncLazyIterable]] against the given `predicate`, returning `true` if it is satisfied at least once.
   * As an eager method, calling `some` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @param predicate
   * @returns A `Promise` that resolves to `true` if at least one value satisfies the given `predicate`, else `false`.
   *
   * @see [[LazyIterable.some]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some|MDN - Array.prototype.some()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async some(predicate: (value: T, index: number) => boolean): Promise<boolean> {
    for await (const [i, value] of enumerateAsync(this)) {
      if (predicate(value, i) === true) {
        return true;
      }
    }
    return false;
  }
  /**
   * Tests values yielded from the [[AsyncLazyIterable]] against the given `predicate`, returning `true` if it is satisfied every time.
   * As an eager method, calling `every` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @param predicate
   * @returns A `Promise` that resolves to `true` if every value satisfies the given `predicate`, else `false`.
   *
   * @see [[LazyIterable.every]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every|MDN - Array.prototype.every()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async every(predicate: (value: T, index: number) => boolean): Promise<boolean> {
    for await (const [i, value] of enumerateAsync(this)) {
      if (predicate(value, i) === false) {
        return false;
      }
    }
    return true;
  }
  /**
   * Determines if the [[AsyncLazyIterable]] yielded a given value `search`.
   * As an eager method, calling `includes` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @param search The value to search for.
   * @returns A `Promise` that resolves to `true` if the given value was yielded, else `false`.
   *
   * @see [[LazyIterable.includes]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|MDN - Array.prototype.includes()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async includes(search: T): Promise<boolean> {
    for await (const value of this) {
      if (value === search) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the first value yielded by the [[AsyncLazyIterable]] that satisfies the given `predicate`.
   * As an eager method, calling `find` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @param predicate
   * @returns A `Promise` that resolves to the value of the first element that satisfies the given `predicate`, or `undefined` if no value exists.
   *
   * @see [[LazyIterable.find]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find|MDN - Array.prototype.find()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async find(predicate: (value: T, index: number) => boolean): Promise<T | undefined> {
    for await (const [i, value] of enumerateAsync(this)) {
      if (predicate(value, i) === true) {
        return value;
      }
    }
    return undefined;
  }
  /**
   * Returns the index of the value that matches the given `search` value; in a [[AsyncLazyIterable]], this translates to the number of values that have been yielded before an instance of `search` is found.
   * As an eager method, calling `indexOf` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases.
   *
   * @param search The value to search for.
   * @returns A `Promise` that resolves to how many values had been yielded from the [[AsyncLazyIterable]] before `search`, or -1 if `search` is never yielded.
   *
   * @see [[LazyIterable.indexOf]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|MDN - Array.prototype.indexOf()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async indexOf(search: T): Promise<number> {
    for await (const [i, value] of enumerateAsync(this)) {
      if (value === search) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns the last index of the value that matches the given `search` value; in a [[AsyncLazyIterable]], this translates to the number of values that have been yielded before the last instance of `search` is found.
   * As an eager method, calling `lastIndexOf` will trigger an evaluation of the [[AsyncLazyIterable]]. Since values cannot be re-yielded once run,
   * it may be more appropriate to use the standard `Array` method for some use cases. The [[AsyncLazyIterable]] must also be finite for this method to work.
   *
   * Note the difference between this method and the standard `Array` implementation; because a [[AsyncLazyIterable]] encapsulates a stream of values that have yet to be fully evaluated,
   * `lastIndexOf` cannot search backwards, and so this method on its own is likely much less efficient.
   *
   * @param search The value to search for.
   * @returns A `Promise` that resolves to how many values had been yielded from the [[AsyncLazyIterable]] before the last instance of `search`, or -1 if `search` is never yielded.
   *
   * @see [[LazyIterable.lastIndexOf]] for more information
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|MDN - Array.prototype.lastIndexOf()} for the standard `Array` method.
   * @since 1.0.0
   * @category Eager
   */
  public async lastIndexOf(search: T): Promise<number> {
    let lastIndex = -1;
    for await (const [i, value] of enumerateAsync(this)) {
      if (value === search) {
        lastIndex = i;
      }
    }
    return lastIndex;
  }
  /**
   * Converts an `AsyncIterable` into a new [[AsyncLazyIterable]]. The input can be anything that implements the `@@asyncIterator` method.
   * To create a [[AsyncLazyIterable]] from an `AsyncGenerator`, the standard [[constructor]] function can be used.
   *
   * @example Convert a custom `AsyncIterable` into a [[AsyncLazyIterable]]
   * ```typescript
   * const customIterable = {
   *   async* [Symbol.iterator]() {
   *     yield 1
   *     yield 2
   *   }
   * }
   * const lazyIterable = AsyncLazyIterable.fromIterable(customIterable)
   * ```
   *
   * @typeParam S - The type returned from the input iterable
   * @param iterable
   * @returns A new [[AsyncLazyIterable]]
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators|MDN - Iterators and generators} for more detail
   * @since 1.0.0
   * @category Conversion
   */
  public static fromIterable<S>(iterable: AsyncIterable<S>): AsyncLazyIterable<S> {
    return new AsyncLazyIterable(
      (async function* () {
        yield* iterable;
      })(),
    );
  }
  /**
   * Convert this [[AsyncLazyIterable]] into an [[LazyIterable]].
   * This triggers a full evaluation of the [[AsyncLazyIterable]], resolving each value in serial and feeding the resultant list
   * into a [[LazyIterable]]; thus, the `Promise` returned from this method will not resolve until value has been resolved.
   * It also means that the [[AsyncLazyIterable]] must not be infinite.
   *
   * @example Convert an [[AsyncLazyIterable]] to a [[LazyIterable]]
   * ```typescript
   * async function* generator() { yield* ["A", "B", "C", "D"] }
   * const asyncIterable = new AsyncLazyIterable(generator())
   * const syncIterable = await asyncIterable.toSynchronousIterable()
   * ```
   *
   * @returns A `Promise` that resolves to a new [[LazyIterable]]
   *
   * @see [[LazyIterable.toAsyncIterable]] for the reverse process
   * @since 1.0.0
   * @category Conversion
   */
  public async toSynchronousIterable(): Promise<LazyIterable<T>> {
    const result = await this.toArray();
    return LazyIterable.fromIterable(result);
  }
  /**
   * Returns a standard `Array` containing the values yielded from the [[AsyncLazyIterable]] in order.
   * This triggers a full evaluation of the [[AsyncLazyIterable]], resolving each value in serial and building an `Array`; thus, the `Promise` returned from this method will not resolve until value has been resolved.
   * It also means that the [[AsyncLazyIterable]] must not be infinite.
   *
   * @example Convert an [[AsyncLazyIterable]] to an `Array`
   * ```typescript
   * async function* generator() { yield* ["A", "B", "C", "D"] }
   * const asyncIterable = new AsyncLazyIterable(generator())
   * const array = await asyncIterable.toArray()
   * ```
   *
   * @returns A new `Array` instance
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from|MDN - Array.reverse()} for the standard `Array` method.
   * @since 1.0.0
   * @category Conversion
   */
  public async toArray(): Promise<T[]> {
    const result = [];
    for await (const value of this) {
      result.push(value);
    }
    return result;
  }
}
